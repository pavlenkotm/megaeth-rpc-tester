"""
Additional export formats for test results.

Support for Markdown, XML, and other export formats.
"""

from typing import Dict, List, Optional, Any
from datetime import datetime
import xml.etree.ElementTree as ET
from xml.dom import minidom


class MarkdownExporter:
    """Export test results to Markdown format."""

    @staticmethod
    def export(results: Dict[str, Any], output_path: str,
              include_charts: bool = False):
        """
        Export results to Markdown file.

        Args:
            results: Test results dictionary
            output_path: Output file path
            include_charts: Include chart placeholders
        """
        md_content = MarkdownExporter._generate_markdown(results, include_charts)

        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(md_content)

    @staticmethod
    def _generate_markdown(results: Dict[str, Any], include_charts: bool = False) -> str:
        """Generate Markdown content."""
        lines = [
            "# RPC Test Results",
            "",
            f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            "",
            "---",
            ""
        ]

        # Summary section
        total_endpoints = len(results)
        total_tests = sum(len(methods) for methods in results.values())

        lines.extend([
            "## Summary",
            "",
            f"- **Total Endpoints Tested:** {total_endpoints}",
            f"- **Total Tests Performed:** {total_tests}",
            ""
        ])

        # Results by endpoint
        for endpoint, methods in results.items():
            lines.extend([
                f"## Endpoint: `{endpoint}`",
                "",
                "### Test Results",
                ""
            ])

            # Create table
            lines.extend([
                "| Method | Requests | Success Rate | Avg Latency | P95 | P99 |",
                "|--------|----------|--------------|-------------|-----|-----|"
            ])

            for method, stats in methods.items():
                row = (
                    f"| `{method}` "
                    f"| {stats.get('total_requests', 0)} "
                    f"| {stats.get('success_rate', 0):.2f}% "
                    f"| {stats.get('avg_latency_ms', 0):.2f}ms "
                    f"| {stats.get('p95_latency_ms', 0):.2f}ms "
                    f"| {stats.get('p99_latency_ms', 0):.2f}ms |"
                )
                lines.append(row)

            lines.append("")

            # Detailed metrics
            lines.extend([
                "### Detailed Metrics",
                ""
            ])

            for method, stats in methods.items():
                lines.extend([
                    f"#### `{method}`",
                    "",
                    "| Metric | Value |",
                    "|--------|-------|",
                    f"| Total Requests | {stats.get('total_requests', 0)} |",
                    f"| Successful | {stats.get('successful_requests', 0)} |",
                    f"| Failed | {stats.get('failed_requests', 0)} |",
                    f"| Success Rate | {stats.get('success_rate', 0):.2f}% |",
                    f"| Min Latency | {stats.get('min_latency_ms', 0):.2f}ms |",
                    f"| Max Latency | {stats.get('max_latency_ms', 0):.2f}ms |",
                    f"| Avg Latency | {stats.get('avg_latency_ms', 0):.2f}ms |",
                    f"| Median (P50) | {stats.get('p50_latency_ms', 0):.2f}ms |",
                    f"| P95 Latency | {stats.get('p95_latency_ms', 0):.2f}ms |",
                    f"| P99 Latency | {stats.get('p99_latency_ms', 0):.2f}ms |",
                    ""
                ])

            if include_charts:
                lines.extend([
                    "### Performance Charts",
                    "",
                    "*(Chart placeholder - integrate with charting library)*",
                    ""
                ])

        lines.extend([
            "---",
            "",
            "*Report generated by MegaETH RPC Tester*"
        ])

        return "\n".join(lines)


class XMLExporter:
    """Export test results to XML format."""

    @staticmethod
    def export(results: Dict[str, Any], output_path: str):
        """
        Export results to XML file.

        Args:
            results: Test results dictionary
            output_path: Output file path
        """
        xml_content = XMLExporter._generate_xml(results)

        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(xml_content)

    @staticmethod
    def _generate_xml(results: Dict[str, Any]) -> str:
        """Generate XML content."""
        root = ET.Element('rpc_test_results')
        root.set('generated_at', datetime.now().isoformat())

        # Summary
        summary = ET.SubElement(root, 'summary')
        ET.SubElement(summary, 'total_endpoints').text = str(len(results))
        total_tests = sum(len(methods) for methods in results.values())
        ET.SubElement(summary, 'total_tests').text = str(total_tests)

        # Endpoints
        endpoints_elem = ET.SubElement(root, 'endpoints')

        for endpoint, methods in results.items():
            endpoint_elem = ET.SubElement(endpoints_elem, 'endpoint')
            endpoint_elem.set('url', endpoint)

            methods_elem = ET.SubElement(endpoint_elem, 'methods')

            for method, stats in methods.items():
                method_elem = ET.SubElement(methods_elem, 'method')
                method_elem.set('name', method)

                # Add all statistics
                for key, value in stats.items():
                    elem = ET.SubElement(method_elem, key)
                    elem.text = str(value)

        # Pretty print XML
        xml_str = ET.tostring(root, encoding='unicode')
        dom = minidom.parseString(xml_str)
        return dom.toprettyxml(indent='  ')


class JSONLExporter:
    """Export test results to JSON Lines format."""

    @staticmethod
    def export(results: Dict[str, Any], output_path: str):
        """
        Export results to JSONL file (one JSON object per line).

        Args:
            results: Test results dictionary
            output_path: Output file path
        """
        import json

        with open(output_path, 'w', encoding='utf-8') as f:
            timestamp = datetime.now().isoformat()

            for endpoint, methods in results.items():
                for method, stats in methods.items():
                    record = {
                        'timestamp': timestamp,
                        'endpoint': endpoint,
                        'method': method,
                        **stats
                    }
                    f.write(json.dumps(record) + '\n')


class PrometheusExporter:
    """Export metrics in Prometheus format."""

    @staticmethod
    def export(results: Dict[str, Any], output_path: str):
        """
        Export results to Prometheus text format.

        Args:
            results: Test results dictionary
            output_path: Output file path
        """
        metrics = PrometheusExporter._generate_prometheus_metrics(results)

        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(metrics)

    @staticmethod
    def _generate_prometheus_metrics(results: Dict[str, Any]) -> str:
        """Generate Prometheus metrics format."""
        lines = [
            "# HELP rpc_test_latency_milliseconds RPC test latency in milliseconds",
            "# TYPE rpc_test_latency_milliseconds gauge",
            "",
            "# HELP rpc_test_success_rate RPC test success rate percentage",
            "# TYPE rpc_test_success_rate gauge",
            "",
            "# HELP rpc_test_requests_total Total number of requests",
            "# TYPE rpc_test_requests_total counter",
            ""
        ]

        timestamp = int(datetime.now().timestamp() * 1000)

        for endpoint, methods in results.items():
            for method, stats in methods.items():
                labels = f'endpoint="{endpoint}",method="{method}"'

                # Latency metrics
                avg_latency = stats.get('avg_latency_ms', 0)
                lines.append(
                    f'rpc_test_latency_milliseconds{{{labels},quantile="avg"}} '
                    f'{avg_latency} {timestamp}'
                )

                p95 = stats.get('p95_latency_ms', 0)
                lines.append(
                    f'rpc_test_latency_milliseconds{{{labels},quantile="0.95"}} '
                    f'{p95} {timestamp}'
                )

                p99 = stats.get('p99_latency_ms', 0)
                lines.append(
                    f'rpc_test_latency_milliseconds{{{labels},quantile="0.99"}} '
                    f'{p99} {timestamp}'
                )

                # Success rate
                success_rate = stats.get('success_rate', 0)
                lines.append(
                    f'rpc_test_success_rate{{{labels}}} {success_rate} {timestamp}'
                )

                # Request counts
                total = stats.get('total_requests', 0)
                lines.append(
                    f'rpc_test_requests_total{{{labels},status="total"}} {total} {timestamp}'
                )

                successful = stats.get('successful_requests', 0)
                lines.append(
                    f'rpc_test_requests_total{{{labels},status="success"}} {successful} {timestamp}'
                )

                failed = stats.get('failed_requests', 0)
                lines.append(
                    f'rpc_test_requests_total{{{labels},status="failed"}} {failed} {timestamp}'
                )

                lines.append("")

        return "\n".join(lines)


class ExporterRegistry:
    """Registry for managing multiple exporters."""

    def __init__(self):
        """Initialize exporter registry."""
        self.exporters = {
            'markdown': MarkdownExporter,
            'xml': XMLExporter,
            'jsonl': JSONLExporter,
            'prometheus': PrometheusExporter
        }

    def register_exporter(self, name: str, exporter_class):
        """Register custom exporter."""
        self.exporters[name] = exporter_class

    def export(self, results: Dict[str, Any], output_dir: str,
              formats: List[str]):
        """
        Export results in multiple formats.

        Args:
            results: Test results
            output_dir: Output directory
            formats: List of format names
        """
        from pathlib import Path

        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)

        for fmt in formats:
            if fmt not in self.exporters:
                print(f"Warning: Unknown export format '{fmt}'")
                continue

            exporter = self.exporters[fmt]
            file_ext = {
                'markdown': '.md',
                'xml': '.xml',
                'jsonl': '.jsonl',
                'prometheus': '.prom'
            }.get(fmt, f'.{fmt}')

            file_path = output_path / f'results{file_ext}'
            exporter.export(results, str(file_path))
            print(f"Exported {fmt} report to: {file_path}")

    def get_available_formats(self) -> List[str]:
        """Get list of available export formats."""
        return list(self.exporters.keys())
